# Cline Rules

## Role Definition

Full-stack engineer proficient in using Hono.

## Technology Stack

- Backend (under api directory)
  - hono
  - zod
  - typescript
  - prisma
  - biome
- Frontend (under client directory)
  - To be built in the future
- Database
  - postgresql
  - docker
- Others
  - npm

## Application Description

This application is a clone of X (formerly Twitter). Users can log in and post their tweets.
Users can follow other users, and tweets from followed users will appear in their timeline.
Users can favorite and retweet other users' tweets.

We use the postgres container described in compose.yaml as the database.
We connect to that postgres container with prisma, and write an API that returns data according to the routing configured in the backend.
The frontend sends requests to that API and renders in the browser. (The frontend will be built in the future)

### How to Launch the Project

1. Run npm run dev in the api directory
2. Access http://localhost:8080

## Expected Response

- Think in English, respond in detail in Japanese


## Coding Standards

- Functional Approach
  - Prioritize pure functions
  - Use immutable data structures
  - Isolate side effects
  - Ensure type safety
- Typescript
  - Use specific types
    - Avoid using any
    - Use unknown and then narrow down types
    - Utilize Utility Types
  - Use meaningful names
  - Clarify the meaning of types
- Test-Driven Development
  - Red-Green-Refactor cycle
  - Treat tests as specifications
  - Iterate in small units
  - Continuous refactoring
- Adhere to standard rules of Biome, ESLint, Prettier
  - Run `npm run check` in the api directory
- Domain-Driven Design (DDD)
  - Distinguish between Value Objects and Entities
  - Ensure consistency through Aggregates
  - Abstract data access with Repositories
  - Be conscious of Bounded Contexts

## Implementation Patterns

### Result Type

```typescript
type Result<T, E> = { ok: true; value: T } | { ok: false; error: E };
```

- Explicitly indicate success/failure
- Use early return pattern
- Define error types

### Type Definitions

```typescript
type Branded<T, B> = T & { _brand: B };
type Money = Branded<number, "Money">;
type Email = Branded<string, "Email">;
```

- Ensure type safety with branded types

### Entity

- Identity based on ID
- Controlled updates
- Has consistency rules

### Repository

- Handles only domain models
- Hides persistence details
- Provides in-memory implementation for testing

### Adapter Pattern

- Abstracts external dependencies
- Interface defined by the caller
- Easily replaceable during testing

## Code Style

- Function-first (classes only when necessary)
- Utilize immutable update patterns
- Flatten conditional branches with early returns
- Define enums for errors and use cases

## Testing Standards

### Common

- Do not create __tests__ directories
- Create in the same directory as the target file
- Unify file names with .test.ts
- When creating a new test file
  - Refer to the style of existing test code
    - When working in the api directory, refer to test code in the api directory
    - When working in the client directory, refer to test code in the client directory
  - If the same mock appears in multiple files and can be reused, extract it to a separate file
- Prioritize unit testing of pure functions
- Incorporate testability into design
- Use assert-first to work backward from expected results
- If tests continue to fail, report the problem to the user and ask for instructions

### api directory

- Mock parts using Prisma so that they don't access the actual database
- Mock parts dependent on external APIs so that actual requests do not occur
- Run the command "npm run test {target file}"

## Directory Structure Rules

```
docs/ # Documentation location
api/  # API
client/ # Frontend
```

## Test-Driven Development (TDD) Basics

### Basic Concepts

Test-Driven Development (TDD) is a development approach that proceeds through the following cycle:

1. **Red**: First, write a failing test
2. **Green**: Implement minimally to make the test pass
3. **Refactor**: Improve the code through refactoring

### Key Concepts

- **Tests are specifications**: Test code expresses the specifications of the implementation
- **Think in Assert-Act-Arrange order**:
  1. First define the expected result (assertion)
  2. Then define the operation (processing of the test target)
  3. Finally define the preparation (setup of the test environment)
- **Test names should be in "situation→operation→result" format**: Example:
  "Should successfully retrieve user information when given a valid token"

## Branch Strategy

### 1. Basic Rules

- Always develop on feature branches
- Keep the main branch in a stable state
- Implement features and fix bugs on separate branches

### 2. Branch Naming Conventions

- Feature addition: `feature/feature-name`
- Bug fixes: `fix/bug-description`
- Refactoring: `refactor/description`
- Documentation: `docs/description`
- Configuration changes: `chore/description`

### 3. Work Start Procedure (REQUIRED)

1. ALWAYS create a new branch from the latest main branch
   ```bash
   git switch main
   git pull origin main
   git switch -c feature/feature-name
   ```

## Coding Standards

- Functional Approach
  - Prioritize pure functions
  - Use immutable data structures
  - Isolate side effects
  - Ensure type safety
- Typescript
  - Use specific types
    - Avoid using any
    - Use unknown and then narrow down types
    - Utilize Utility Types
  - Use meaningful names
  - Clarify the meaning of types
- Test-Driven Development
  - Red-Green-Refactor cycle
  - Treat tests as specifications
  - Iterate in small units
  - Continuous refactoring
- Adhere to standard rules of Biome, ESLint, Prettier
  - Run `npm run check` in the api directory
- Domain-Driven Design (DDD)
  - Distinguish between Value Objects and Entities
  - Ensure consistency through Aggregates
  - Abstract data access with Repositories
  - Be conscious of Bounded Contexts

## Implementation Patterns

### Result Type

```typescript
type Result<T, E> = { ok: true; value: T } | { ok: false; error: E };
```

- Explicitly indicate success/failure
- Use early return pattern
- Define error types

### Type Definitions

```typescript
type Branded<T, B> = T & { _brand: B };
type Money = Branded<number, "Money">;
type Email = Branded<string, "Email">;
```

- Ensure type safety with branded types

### Entity

- Identity based on ID
- Controlled updates
- Has consistency rules

### Repository

- Handles only domain models
- Hides persistence details
- Provides in-memory implementation for testing

### Adapter Pattern

- Abstracts external dependencies
- Interface defined by the caller
- Easily replaceable during testing

## Code Style

- Function-first (classes only when necessary)
- Utilize immutable update patterns
- Flatten conditional branches with early returns
- Define enums for errors and use cases

## Testing Standards

### Common

- Do not create __tests__ directories
- Create in the same directory as the target file
- Unify file names with .test.ts
- When creating a new test file
  - Refer to the style of existing test code
    - When working in the api directory, refer to test code in the api directory
    - When working in the client directory, refer to test code in the client directory
  - If the same mock appears in multiple files and can be reused, extract it to a separate file
- Prioritize unit testing of pure functions
- Incorporate testability into design
- Use assert-first to work backward from expected results
- If tests continue to fail, report the problem to the user and ask for instructions

### api directory

- Mock parts using Prisma so that they don't access the actual database
- Mock parts dependent on external APIs so that actual requests do not occur
- Run the command "npm run test {target file}"

## Directory Structure Rules

```
docs/ # Documentation location
api/  # API
client/ # Frontend
```

## Test-Driven Development (TDD) Basics

### Basic Concepts

Test-Driven Development (TDD) is a development approach that proceeds through the following cycle:

1. **Red**: First, write a failing test
2. **Green**: Implement minimally to make the test pass
3. **Refactor**: Improve the code through refactoring

### Key Concepts

- **Tests are specifications**: Test code expresses the specifications of the implementation
- **Think in Assert-Act-Arrange order**:
  1. First define the expected result (assertion)
  2. Then define the operation (processing of the test target)
  3. Finally define the preparation (setup of the test environment)
- **Test names should be in "situation→operation→result" format**: Example:
  "Should successfully retrieve user information when given a valid token"

## Branch Strategy

### 1. Basic Rules

- Always develop on feature branches
- Keep the main branch in a stable state
- Implement features and fix bugs on separate branches

### 2. Branch Naming Conventions

- Feature addition: `feature/feature-name`
- Bug fixes: `fix/bug-description`
- Refactoring: `refactor/description`
- Documentation: `docs/description`
- Configuration changes: `chore/description`



### 5. Commit Message Creation Procedure (REQUIRED)

1. Perform verification after code changes
  - Ensure there are no code compilation errors
  - Ensure tests for changed files succeed

2. Create the message content for memory_bank_commit_message.txt file
  - Write the message according to the basic structure above
  - Always include prompt history
  - Appropriately summarize the changes
  - Write commit messages in Japanese

3. Provide only the created message content as the answer
  - Do not execute commands
  - Prompt the user to commit with: "Please commit these changes using the message above"
  - The user manually executes the commit
  - Wait for confirmation that the commit was successful before continuing

## Commit Message Conventions

### 1. Basic Structure

<type>(<scope>): <subject>

<body>

<footer>

# Prompt History
<prompt_history>

### 2. Description of Elements

#### type

- feature: New feature
- fix: Bug fix
- docs: Documentation only changes
- style: Changes that don't affect code meaning (whitespace, formatting, adding semicolons, etc.)
- refactor: Code changes that neither fix bugs nor add features
- test: Adding or correcting tests
- chore: Changes to build processes or auxiliary tools and libraries

#### scope

- Indicates the scope of influence of the change
- Separate with commas if there are multiple scopes
- Optional for global changes

#### subject

- Concise summary of the change

#### body

- Detailed explanation of the change
- Can be described in multiple lines with line breaks
- Explanation of why the change was necessary
- Line break at 72 characters

#### prompt_history

- Record of prompts instructed by the user
- Include additional context information related to the prompt

### 3. Commit Message Example

feature(tweets): Add tweet posting functionality

- Implement tweet posting functionality
- Add validation for posting

# Prompt History

1. Q: Please implement tweet posting functionality
  A: Implemented tweet posting functionality and added validation for posting conditions

### 4. Commit Message Command Restrictions

- If a commit message is created, do not execute the command
- Provide only the created message content as the answer
- Commands must always be executed manually by the user



### 3. Pull Request Command Restrictions (REQUIRED)

- Before completing any task, ALWAYS create a pull request command
- Do not execute the command yourself
- Provide only the created command content as the answer
- Prompt the user to create the pull request with: "Please create a pull request using the command above"
- Commands must always be executed manually by the user
- Wait for confirmation that the pull request was created before marking work as complete

### 6. Notes

- Include only one logical change in one commit
- Divide into multiple commits if there are multiple changes
- Commit messages can be written in Japanese
- Always include prompt history for change traceability
- Use commit_message.txt as a temporary file

## Pull Request Creation Conventions

### 1. Basic Rules

- Base branch is fixed to main
- Title and body are written in Japanese

### 2. Creating Title and Body

#### Title
- Concisely summarize the commit content included in the branch
- Format: `Commit type: Summary of changes`
- Example: `feature: Add document review approval function`

#### Body
- Extract key changes from commit history and describe in list format
- Include background and purpose of changes
- Include test execution results and operation verification results


### 4. Using gh Command

# Get current branch name
current_branch=$(git branch --show-current)

# Pull request creation command
gh pr create \
  --base main \
  --head "$current_branch" \
  --title "[Commit type] Summary of changes" \
  --body '## Changes

- Change 1
- Change 2
- Change 3

## Background and Purpose of Changes

- Explanation of background
- Explanation of purpose

## Test Results

- [ ] Unit tests executed
- [ ] Operation verified

### 4. Notes When Requesting Review

- Clearly state points that need special attention
- Add supplementary explanations for complex parts of the code'
